{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"浅谈IM","slug":"IM 即时通讯","date":"2024-04-13T11:14:16.335Z","updated":"2024-04-12T13:20:56.791Z","comments":true,"path":"2024/04/13/IM 即时通讯/","permalink":"http://example.com/2024/04/13/IM%20%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/","excerpt":"","text":"现代IM系统中聊天消息的同步和存储方案探讨 - 知乎 (zhihu.com) 浅谈IM系统中离线消息、历史消息的最佳实践 IM系统中最核心的部分是消息系统，消息系统中最核心的功能是消息的同步和存储： 1）消息的同步：将消息完整的、快速的从发送方传递到接收方，就是消息的同步。消息同步系统最重要的衡量指标就是消息传递的实时性、完整性以及能支撑的消息规模。从功能上来说，一般至少要支持在线和离线推送，高级的IM系统还支持『多端同步』；2）消息的存储：消息存储即消息的持久化保存，这里不是指消息在客户端本地的保存，而是指云端的保存，功能上对应的就是『消息漫游』。『消息漫游』的好处是可以实现账号在任意端登陆查看所有历史消息，这也是高级IM系统特有的功能之一。 架构设计传统架构下，消息是先同步后存储： 对于在线的用户，消息会直接实时同步到在线的接收方，消息同步成功后，并不会进行持久化。而对于离线的用户或者消息无法实时同步成功时，消息会持久化到离线库，当接收方重新连接后，会从离线库拉取所有未读消息。当离线库中的消息成功同步到接收方后，消息会从离线库中删除。传统的消息系统，服务端的主要工作是维护发送方和接收方的连接状态，并提供在线消息同步和离线消息缓存的能力，保证消息一定能够从发送方传递到接收方。服务端不会对消息进行持久化，所以也无法支持消息漫游。 现代架构下，消息是先存储后同步： 先存储后同步的好处是，如果接收方确认接收到了消息，那这条消息一定是已经在云端保存了。并且消息会有两个库来保存，一个是消息存储库，用于全量保存所有会话的消息，主要用于支持消息漫游。另一个是消息同步库，主要用于接收方的多端同步。消息从发送方发出后，经过服务端转发，服务端会先将消息保存到消息存储库，后保存到消息同步库。完成消息的持久化保存后，对于在线的接收方，会直接选择在线推送。但在线推送并不是一个必须路径，只是一个更优的消息传递路径。对于在线推送失败或者离线的接收方，会有另外一个统一的消息同步方式。接收方会主动的向服务端拉取所有未同步消息，但接收方何时来同步以及会在哪些端来同步消息对服务端来说是未知的，所以要求服务端必须保存所有需要同步到接收方的消息，这是消息同步库的主要作用。对于新的同步设备，会有消息漫游的需求，这是消息存储库的主要作用，在消息存储库中，可以拉取任意会话的全量历史消息。 1、IM消息投递的一般做法在通常的IM消息系统中，对于实时消息、离线消息、历史消息大概都是下面这样的技术思路。 对于在线用户：消息会直接实时发送到在线的接收方，消息发送完成后，服务器端并不会对消息进行落地存储。 而对于离线的用户：服务器端会将消息存入到离线库，当用户登录后，从离线库中将离线消息拉走，然后服务器端将离线消息删除。 这样实现的缺点就是消息不持久化，导致消息无法支持消息漫游，降低了消息的可靠性。 （PS：实际上，这其实也不能算是缺点，因为一些场景下存储历史消息并不是必须的，所谓的消息漫游能力也不是必备的，比如微信。） 而在我们设计的消息系统中，服务器只要接收到了发送方发上来的消息，在转发给接收方的同时也会在离线数据库及历史消息库中进行消息的落地存储，而历史消息的落地也就能支持消息漫游等相关功能了。 2、什么是离线消息和历史消息？关于离线消息和历史消息，在技术上，我们是这样定义。 1）离线消息： 离线消息就是用户（即接收方）在离线过程中收到的消息，这些消息大多是用户比较关心的消息，具有一定的时效性。 以我们的系统经验来说，我们的离线消息默认只保存最近七天的消息。 用户（即接收方）在下次登录后会全量获取这些离线消息，然后在客户端根据聊天会话进行离线消息的UI展示（比如显示一个未读消息气泡等）。 （PS：用户离线的可能性在技术上其实是由很多种情况组成的，比如对方不在线、对方网络断掉了、对方手机崩溃了、服务器发送时出错了等等，严格来讲——只要无法实时发送成的消息，都算“离线消息”。） 2）历史消息： 历史消息存储了用户所有的聊天消息，这些消息包括发出的消息以及接收到的消息。 在客户端获取历史消息时，通常是按照会话进行分页获取的。 以我们的系统经验来说，历史消息的存储时间我们设计默认为半年，当然这个时间可以按实际的产品运营规则来定，没有硬性规定。 3、IM消息的发送及存储流程以下是我们系统整体的消息发送及存储流程： 6、IM离线消息、历史消息在存储逻辑上的区别(扩散写 扩散读)6.1概述通过上面的图中能清晰的看到： 1）离线消息我们存储介质选用的是 Redis； 2）历史消息我们选用的是 HBase。 对于为什么选用不同的存储介质，其实我们考虑的是离线消息和历史消息不同的业务场景和读写模式。 下面我们重点介绍一下离线消息和历史消息存储的区别。 6.2离线消息存储模式——“扩散写”离线消息的存储模式我们用的是扩散写。 如上图所示：每个用户都有自己单独的收件箱和发件箱： 1）收件箱存放的是需要向这个接收端同步的所有消息； 2）发件箱里存放的是发送端发出的所有消息。以单聊为例：聊天中的两人会话中，消息会产生两次写，即发送者的发件箱和接收端的收件箱。 而在群的场景下：写入会被更加的放大（扩散），如果群里有 N 个人，那一条群消息就会被扩散写 N 次。 小结一下： 1）扩散写的优点是：接收端的逻辑会非常清晰简单，只需要从收件箱里读取一次即可，大大降低了同步消息所需的读的压力； 2）扩散写的缺点是：写入会被成指数地放大，特别是针对群这种场景。 6.3历史消息存储模式——“扩散读”历史消息的存储模式我们用的是扩散读。 因为历史消息中，每个会话都保存了整个会话的全量消息。在扩散读这种模式下，每个会话的消息只保存一次。 对比扩散写模式，扩散读的优点和缺点如下： ***1）***优点是：写入次数大大降低，特别是针对群消息，只需要存一次即可； ***2）***缺点是：接收端接收消息非常的复杂和低效，因为这种模式客户端想拉取到所有消息就只能每个会话同步一次，读就会被放大，而且可能会产生很多次无效的读，因为有些会话可能根本没有新消息。 6.4小结在 IM 这种应用场景下，通常会用到扩散写这种消息同步模型，一条消息产生一条，但是可能会被读多次，是典型的读多写少的场景。 一个优化好的IM系统，必须从设计上平衡读写压力，避免读或者写任意一个维度达到天花板。 当然扩散写这种模式也有其弊端，比如万人群，会导致一条消息，写入了一万次。 综合来讲：我们需要根据自己的业务场景做相应设计选择，以我们的IM系统为例，就是是根据了离线和历史消息的不同场景选择了写扩散和读扩散的组合模式。适合的才是最好的，没有必要死搬硬套理论。 具体实现 :寻航聊天功能消息存储：所有消息存在mysql 做持久化 离线消息 Redis每个用户设置一个收件箱 zset 按时间排序","categories":[{"name":"IM","slug":"IM","permalink":"http://example.com/categories/IM/"}],"tags":[]},{"title":"my new post","slug":"my-new-post","date":"2024-04-13T11:13:27.000Z","updated":"2024-04-13T11:13:27.321Z","comments":true,"path":"2024/04/13/my-new-post/","permalink":"http://example.com/2024/04/13/my-new-post/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-04-13T10:53:50.850Z","updated":"2024-04-13T10:53:50.850Z","comments":true,"path":"2024/04/13/hello-world/","permalink":"http://example.com/2024/04/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"IM","slug":"IM","permalink":"http://example.com/categories/IM/"}],"tags":[]}